var documenterSearchIndex = {"docs":
[{"location":"optional/#Optional-API-functions","page":"Optional API functions","title":"Optional API functions","text":"","category":"section"},{"location":"optional/","page":"Optional API functions","title":"Optional API functions","text":"These methods have default implementations, but depending on the characteristics of your ThickNumber subtype you might prefer to supply your own implementation.","category":"page"},{"location":"optional/","page":"Optional API functions","title":"Optional API functions","text":"Julia Base functions (see Julia's own documentation for details):","category":"page"},{"location":"optional/","page":"Optional API functions","title":"Optional API functions","text":"Base.typemin(::Type{<:ThickNumber})\nBase.typemax(::Type{<:ThickNumber})","category":"page"},{"location":"optional/","page":"Optional API functions","title":"Optional API functions","text":"Exported functions:","category":"page"},{"location":"optional/","page":"Optional API functions","title":"Optional API functions","text":"ThickNumbers.midrad\nThickNumbers.emptyset","category":"page"},{"location":"optional/#ThickNumbers.midrad","page":"Optional API functions","title":"ThickNumbers.midrad","text":"midrad(::Type{TN}, mid, rad) where TN<:ThickNumber\n\nConstruct a TN from its midpoint mid and radius rad.\n\nInterface requirements\n\nIf\n\nx = midrad(TN, mid, rad)\n\nsucceeds without throwing an error and rad >= 0, then it is required that\n\ntypeof(x) <: TN\nrad(x) >= rad && rad(x) ≈ rad\n\nIf rad < 0, then it is required that\n\ntypeof(x) <: TN\nisempty(x)\n\n\n\n\n\n","category":"function"},{"location":"optional/#ThickNumbers.emptyset","page":"Optional API functions","title":"ThickNumbers.emptyset","text":"emptyset(::Type{TN}) where TN<:ThickNumber\nemptyset(x::ThickNumber)\n\nConstruct an \"empty set\" of type TN.\n\nDefault implementation\n\nThe default implementation creates an empty set by making the loval be bigger than the hival. Specifically, the default implementation is\n\nemptyset(::Type{TN}) where TN<:ThickNumber{T} where T = lohi(TN, typemax(T), typemin(T))\n\nExamples\n\njulia> emptyset(Interval{Float64})\nInterval{Float64}(Inf, -Inf)\n\n\n\n\n\n","category":"function"},{"location":"required/#Required-API-functions","page":"Required API functions","title":"Required API functions","text":"","category":"section"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"Each package creating a new ThickNumber subtype must implement:","category":"page"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"loval\nhival","category":"page"},{"location":"required/#ThickNumbers.loval","page":"Required API functions","title":"ThickNumbers.loval","text":"loval(x::ThickNumber)\n\nThe value representing the lower limit of the span of x. loval must be implemented by any subtype of ThickNumber.\n\nExamples\n\njulia> loval(Interval(1, 2))    # suppose Interval{T} <: ThickNumber{T}\n1\n\n\n\n\n\n","category":"function"},{"location":"required/#ThickNumbers.hival","page":"Required API functions","title":"ThickNumbers.hival","text":"hival(x::ThickNumber)\n\nThe value representing the upper limit of the span of x. hival must be implemented by any subtype of ThickNumber.\n\nExamples\n\njulia> hival(Interval(1, 2))    # suppose Interval{T} <: ThickNumber{T}\n2\n\n\n\n\n\n","category":"function"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"If possible, you should also implement:","category":"page"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"lohi","category":"page"},{"location":"required/#ThickNumbers.lohi","page":"Required API functions","title":"ThickNumbers.lohi","text":"lohi(::Type{TN}, lo, hi) where TN<:ThickNumber\n\nConstruct a TN from its lo and hi values.\n\nInterface requirements\n\nlohi must be implemented by all ThickNumber subtypes.\n\nIf\n\nx = lohi(TN, lo, hi)\n\nsucceeds without throwing an error, then it is required that\n\ntypeof(x) <: TN\nlo ∈ x\nhi ∈ x\nlo ≈ loval(x)\nhi ≈ hival(x)\n\nFor the latter two, exact equality is not required; this allows for roundoff error (in case TN is parametrized by something other than its lo and hi values) as well as outward rounding for ThickNumber types that aim to be conservative and guarantee acccuracy even in the presence of roundoff error.\n\n\n\n\n\n","category":"function"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"If your ThickNumber subtype can't be constructed this way, you will likely have to specialize several of the ThickNumber API functions to compensate.","category":"page"},{"location":"required/","page":"Required API functions","title":"Required API functions","text":"You also need to implement any binary arithmetic operations (a + b, a - b, a * b, a / b). Unary + and - (i.e., -x) have default implementations for all ThickNumber subtypes, although you can choose to specialize if warranted.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ThickNumbers","category":"page"},{"location":"#ThickNumbers","page":"Home","title":"ThickNumbers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A ThickNumber{T} is an abstract type denoting objects that act like numbers–they have standard algebraic operations +, -, *, and /–but also have properties of a connected set, specifically occupying some \"width,\" e.g., a segment of the real number line. Examples of possible concrete subtypes include intervals, gaussian random variables, and potentially others. While the parameter T in ThickNumber does not necessarily have to be T<:Real, it should have an ordering so that \"width\" has some meaning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is aimed at:","category":"page"},{"location":"","page":"Home","title":"Home","text":"users who what to know how to manipulate ThickNumber objects. Users should read:\nThe Fundamental Principle of ThickNumbers (FPTN), which explains key differences between ThickNumbers and \"point\" numbers\nThe ThickNumber API, which lists the main functions used to manipulate ThickNumbers.\ndevelopers who want to create a new ThickNumber subtype. Developers should read the two sections above followed by Creating a new ThickNumber subtype, and then refer to the API reference sections as needed.","category":"page"},{"location":"#The-Fundamental-Principle-of-ThickNumbers-(FPTN)","page":"Home","title":"The Fundamental Principle of ThickNumbers (FPTN)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An important issue that must be understood at the outset is a generalization of the Fundamental Theorem of Interval Arithmetic (Moore, R. E. 1966, Interval analysis), which we adopt as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Fundamental Principle of ThickNumbers (FPTN)\nIf f(x::T) is a function and X a ThickNumber{T}, then f(X) should either error or return another ThickNumber such that f(x) ∈ f(X) for \"most\" or all x ∈ X. This principle generalizes to functions with more than one argument, f(x::T, y::T), but does not include mixtures of argument types like f(x::T, X::ThickNumber{T}).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, \"most\" is directed at possible subtypes like Gaussian random variables, where one would expect that f(X) returns a value appropriate for x drawn near the center of the distribution X but not necessarily for those in the tails.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FPTN has subtle implications, particularly for 2-argument functions intended to return a Bool. For example, ==(x, y) is a standard 2-argument Julia function, and the FPTN implies that ==(X::ThickNumber, Y::ThickNumber) cannot be defined (it must error): after all, returning true would imply that x == y for any choice x ∈ X and y ∈ Y, and this is impossible unless X and Y are either empty or each contain only a single value. Concretely, if 1..3 constructs an interval, then 1..3 == 1..3 returning true would require that 1.5 == 1.5 and also 1.5 == 2.5 since both 1.5 and 2.5 can be drawn from 1..3. This is obviously impossible, thus having 1..3 == 1..3 return true would be a violation of the FPTN; it must error instead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because numbers are iterable in Julia, set operations like X ⊆ Y also cannot be defined (it would require that each number in X is a subset of every number in Y); however, operations like intersect(X, Y) (i.e., X ∩ Y) are valid because x ∩ y returns ∅ if x != y and ∅ is a subset of all other sets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To avoid violating the FPTN, we replace operators like == with custom operators that work only on ThickNumber{T} but not T. For Base Julia functions, a convention is to add _tn after the standard function name: isequal_tn(X, Y) replaces the \"intent\" of isequal(X, Y). Often these have unicode equivalents, which typically (though not always) involve a \"dot\" somewhere in the symbol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API section below for a more complete list of these replacements.","category":"page"},{"location":"#The-ThickNumber-API","page":"Home","title":"The ThickNumber API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let x and y refer to a standard \"point\" numbers and X and Y corresponding ThickNumbers such that x ∈ X and y ∈ Y.","category":"page"},{"location":"#Querying-values","page":"Home","title":"Querying values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With only a few exceptions, the names of these come from the Interval Arithmetic Standard (IEEE Std 1788-2015).","category":"page"},{"location":"","page":"Home","title":"Home","text":"loval(X): return the \"lower bound\" (which may not be \"fuzzy\" for some ThickNumber subtypes) of X (similar to inf in the IEEE standard, but without promising the true infimum)\nhival(X): return the \"upper bound\" of X (similar to sup in the IEEE standard)\nmid(X): return the midpoint of X\nwid(X): return the width (hival - loval) of X\nrad(X): return the half-width of X (half the value of wid(X))\nmag(X): the largest absolute value contained in X\nmig(X): the smallest absolute value contained in X","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also check a few basic properties, like whether the values contained in X are finite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"isfinite_tn(X)\nisinf_tn(X)\nisnan_tn(X)","category":"page"},{"location":"#Type-information","page":"Home","title":"Type information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"valuetype(X): return the type of numbers contained in X (e.g., Float64)","category":"page"},{"location":"#Generic-constructors","page":"Home","title":"Generic constructors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each ThickNumber subtype has its own constructor(s), but if you need a way to write generic code that works for multiple ThickNumber subtypes, you may be able to use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lohi: lohi(TN, lo, hi) creates a ThickNumber X where typeof(X) <: TN, loval(X) ≈ lo, and hival(X) ≈ hi. (It's approximate because of floating-point roundoff error and the fact that not all ThickNumber subtypes encode these bounds directly.)\nmidrad creates a ThickNumber from its midpoint and radius (see mid and rad).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that some ThickNumber subtypes might need additional arguments, so there may be some that cannot be constructed generically and for which lohi and midrad might error.","category":"page"},{"location":"#Comparison-operators","page":"Home","title":"Comparison operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For an explanation of why these aren't just ==, <, etc, read The Fundamental Principle of ThickNumbers (FPTN).","category":"page"},{"location":"","page":"Home","title":"Home","text":"iseq_tn (i.e., iseq(X, Y), or the unicode analog X ⩦ Y) checks equality between X and Y (i.e., the replacement for x == y)\nisequal_tn(X, Y) replaces isequal(x, y) (see the Julia docs for the subtle difference between == and isequal).\nisapprox_tn(X, Y) (unicode X ⩪ Y) checks approximate equality (≈) between X and Y\nX ≺ Y (typed with \\prec-TAB) and X ≻ Y (\\succ-TAB) test whether \"all\" values in X are strictly less or greater, respectively, than \"all\" values in Y.\nisless_tn(X, Y) replaces isless(x, y) (see the Julia docs for the subtle difference between < and isless)\nX ⪯ Y (\\preceq-TAB) and X ⪰ Y(\\succeq-TAB) replace <= and >=, respectively.","category":"page"},{"location":"#Set-operations","page":"Home","title":"Set operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"issubset_tn replaces ⊆ (unicode: ⫃)\nis_strict_subset_tn replaces ⊂ (unicode: ⪽)\nissupset_tn replaces ⊇ (unicode: ⫄)\nis_strict_supset_tn replaces ⊃ (unicode: ⪾)\nhull creates a number that contains its arguments","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The API is described more completely in:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"required.md\", \"optional.md\", \"user_api.md\"]","category":"page"},{"location":"developers/#Creating-a-new-ThickNumber-subtype","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"","category":"section"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"tip: Tip\nFor a concrete example, see the ThickNumbersInterfaceTests/test/testpackages/IntervalArith \"package\" in the main source repository of ThickNumbers.jl. You can get a hint of the behaviors this endows by looking at ThickNumbers/test/runtests.jl, which uses the Interval type defined by IntervalArith.","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"Create your type by subtyping ThickNumber{T}:","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"struct MyType{T<:Real} <: ThickNumber{T}\n    # you can have whatever fields you need...\n    a::T\n    b::T\nend","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"If you only intend to support, say, Float64, you can use struct MyType <: ThickNumber{Float64} ... end: the key point is that the T in ThickNumber{T} should encode the valuetype.","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"The following interface functions must be defined:","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"loval(x): should return the lower span (i.e., the \"lower bound\" if such bounds are strict).\nhival(x): should return the upper span.\nany arithmetic operations you need, e.g., +, -, *, and /","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"The implementation of these functions must satisfy certain requirements spelled out in the documentation of each of these functions.","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"If possible, you should also define:","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"lohi(MyType{T}, lo, hi): construct x from two numbers specifying the lower and upper spans.","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"If you cannot define this for your type (e.g., MyType requires more than two arguments to construct), it is likely that you'll have to specialize some of the User API functions for MyType, since the default implementations of some of them rely on lohi.","category":"page"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"There are also numerous optional methods you can specialize if it makes MyType operate more efficiently. For example, a gaussian random variable package might want to implement midrad(MyType{T}, center, σ) to construct values directly, assuming this is the natural parametrization of this type.","category":"page"},{"location":"developers/#Ensuring-compliance-with-the-ThickNumbers-interface","page":"Creating a new ThickNumber subtype","title":"Ensuring compliance with the ThickNumbers interface","text":"","category":"section"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"The ThickNumbersInterfaceTests package can be used to determine whether your implementations comply with the requirements.  As it is possible that this test suite will evolve and add new requirements, be sure to use [compat] bounds to specify the major version number of ThickNumbersInterfaceTests that your implementation satisfies.","category":"page"},{"location":"developers/#Features-provided-by-subtyping-ThickNumber","page":"Creating a new ThickNumber subtype","title":"Features provided by subtyping ThickNumber","text":"","category":"section"},{"location":"developers/","page":"Creating a new ThickNumber subtype","title":"Creating a new ThickNumber subtype","text":"See the User API.","category":"page"},{"location":"user_api/#User-API","page":"User API","title":"User API","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"These are functions you can use on any ThickNumber subtype when writing your code. Generally you shouldn't need to implement these directly (they all have default implementations), although you can of course specialize them as needed as long as your implementation does not violate the interface requirements.","category":"page"},{"location":"user_api/#Types","page":"User API","title":"Types","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"valuetype","category":"page"},{"location":"user_api/#ThickNumbers.valuetype","page":"User API","title":"ThickNumbers.valuetype","text":"valuetype(::Type{<:ThickNumber})\n\nReturn the type of the numbers in the span, i.e., the T in ThickNumber{T}.\n\nExamples\n\njulia> valuetype(Interval{Float64})\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"user_api/#Query-functions","page":"User API","title":"Query functions","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"API functions from the Interval Arithmetic Standard (IEEE Std 1788-2015), Table 9.2 are supported. One (deliberate) exception is inf and sup, which are replaced by loval and hival: inf and sup have well-defined mathematical meanings that may not be appropriate for all ThickNumber subtypes (e.g., gaussian random variables don't have finite lower and upper bounds). If you are creating an interval arithmetic package, of course you can choose to define","category":"page"},{"location":"user_api/","page":"User API","title":"User API","text":"inf(x::MyInterval) = loval(x)\nsup(x::MyInterval) = hival(x)","category":"page"},{"location":"user_api/","page":"User API","title":"User API","text":"in order to comply with the standard.","category":"page"},{"location":"user_api/","page":"User API","title":"User API","text":"mid\nmag\nmig\nrad\nwid\nisfinite_tn\nisinf_tn\nisnan_tn","category":"page"},{"location":"user_api/#ThickNumbers.mid","page":"User API","title":"ThickNumbers.mid","text":"mid(x::ThickNumber)\n\nThe midpoint of the span of x. Required by IEEE Std 1788-2015, Table 9.2.\n\nDefault implementation\n\nThe default implementation is\n\nmid(x::ThickNumber) = (loval(x) + hival(x))/2\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.mag","page":"User API","title":"ThickNumbers.mag","text":"mag(x::ThickNumber)\n\nThe maximum absolute value of x. Required by IEEE Std 1788-2015, Table 9.2.\n\nDefault implementation\n\nThe default implementation is\n\nmag(x::ThickNumber) = max(abs(loval(x)), abs(hival(x)))\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.mig","page":"User API","title":"ThickNumbers.mig","text":"mig(x::ThickNumber)\n\nThe minimum absolute value of x. Required by IEEE Std 1788-2015, Table 9.2.\n\nDefault implementation\n\nThe default implementation checks to see if the set contains zero, and if so returns zero. Otherwise, it returns the minimum absolute value of the endpoints:\n\nmig(x::ThickNumber) = zero(T) ∈ x ? zero(T) : min(abs(loval(x)), abs(hival(x)))\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.rad","page":"User API","title":"ThickNumbers.rad","text":"rad(x::ThickNumber)\n\nHalf the width of the span of x. Required by IEEE Std 1788-2015, Table 9.2.\n\nDefault implementation\n\nThe default implementation is\n\nrad(x::ThickNumber) = wid(x)/2\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.wid","page":"User API","title":"ThickNumbers.wid","text":"wid(x::ThickNumber)\n\nThe width of the span of x. Required by IEEE Std 1788-2015, Table 9.2.\n\nDefault implementation\n\nThe default implementation is\n\nwid(x::ThickNumber) = hival(x) - loval(x)\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isfinite_tn","page":"User API","title":"ThickNumbers.isfinite_tn","text":"isfinite_tn(x::ThickNumber)\n\nReturns true if all values in x are finite, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isinf_tn","page":"User API","title":"ThickNumbers.isinf_tn","text":"isinf_tn(x::ThickNumber)\n\nReturns true if any value in x is infinite, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isnan_tn","page":"User API","title":"ThickNumbers.isnan_tn","text":"isnan_tn(x::ThickNumber)\n\nReturns true if any value in x is NaN, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#Comparison-operators","page":"User API","title":"Comparison operators","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"iseq_tn\nisequal_tn\nisapprox_tn\nisless_tn\n≺\n≻\n⪯\n⪰","category":"page"},{"location":"user_api/#ThickNumbers.iseq_tn","page":"User API","title":"ThickNumbers.iseq_tn","text":"iseq_tn(a::ThickNumber, b::ThickNumber)\na ≐ b  (`\\doteq`-TAB`)\n\nReturns true if a and b are both empty or both loval and hival are equal in the sense of ==. It is false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isequal_tn","page":"User API","title":"ThickNumbers.isequal_tn","text":"isequal_tn(a::ThickNumber, b::ThickNumber)\n\nReturns true if a and b are both empty or both loval and hival are equal in the sense of isequal. It is false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isapprox_tn","page":"User API","title":"ThickNumbers.isapprox_tn","text":"isapprox_tn(a::ThickNumber, b::ThickNumber; atol=0, rtol::Real=atol>0 ? 0 : √eps)\na ⩪ b (`\\dotsim`-TAB)\n\nReturns true if a and b are both empty or both loval and hival are approximately equal (≈). It is false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.isless_tn","page":"User API","title":"ThickNumbers.isless_tn","text":"isless_tn(a::ThickNumber, b::ThickNumber)\n\nReturns true if isless(hival(a), loval(b)), false otherwise. See also ≺.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.:≺","page":"User API","title":"ThickNumbers.:≺","text":"a ≺ b\n\nReturns true if hival(a) < loval(b), false otherwise. Use \\prec-TAB to type.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.:≻","page":"User API","title":"ThickNumbers.:≻","text":"a ≻ b\n\nReturns true if loval(a) > hival(b), false otherwise. Use \\succ-TAB to type.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.:⪯","page":"User API","title":"ThickNumbers.:⪯","text":"a ≼ b\n\nReturns true if hival(a) ≤ loval(b), false otherwise. Use \\preceq-TAB to type.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.:⪰","page":"User API","title":"ThickNumbers.:⪰","text":"a ≽ b\n\nReturns true if loval(a) ≥ hival(b), false otherwise. Use \\succeq-TAB to type.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#Set-operations","page":"User API","title":"Set operations","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"See also IntervalSets for a more flexible way of supporting intervals as sets.","category":"page"},{"location":"user_api/","page":"User API","title":"User API","text":"in(::Real, ::ThickNumber)\nhull\nBase.isempty(::ThickNumber)\nissubset_tn\nissupset_tn\nis_strict_subset_tn\nis_strict_supset_tn","category":"page"},{"location":"user_api/#Base.in-Tuple{Real, ThickNumber}","page":"User API","title":"Base.in","text":"in(x::Real, a::ThickNumber)\n\nReturns true if x is in the span of a (i.e., between loval(a) and hival(a)), false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"user_api/#ThickNumbers.hull","page":"User API","title":"ThickNumbers.hull","text":"hull(a::ThickNumber, b::ThickNumber, c::ThickNumber...)\n\nConstruct a ThickNumber containing a, b, and c....\n\n\n\n\n\n","category":"function"},{"location":"user_api/#Base.isempty-Tuple{ThickNumber}","page":"User API","title":"Base.isempty","text":"isempty(x::ThickNumber)\n\nReturns true if hival(x) < loval(x) is empty, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"user_api/#ThickNumbers.issubset_tn","page":"User API","title":"ThickNumbers.issubset_tn","text":"issubset_tn(a::ThickNumber, b::ThickNumber)\n⫃(a::ThickNumber, b::ThickNumber)\n\nReturns true if a is a subset of b, false otherwise.\n\nSee documentation for why this is not just ⊆\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.issupset_tn","page":"User API","title":"ThickNumbers.issupset_tn","text":"issupset_tn(a::ThickNumber, b::ThickNumber)\n⫄(a::ThickNumber, b::ThickNumber)\n\nThe converse of issubset_tn.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.is_strict_subset_tn","page":"User API","title":"ThickNumbers.is_strict_subset_tn","text":"is_strict_subset_tn(a::ThickNumber, b::ThickNumber)\n⪽(a::ThickNumber, b::ThickNumber)\n\nReturns true if a is a strict subset of b, false otherwise. a is a strict subset if a is a subset of b not equal to b.\n\nSee documentation for why this is not just ⊂.\n\n\n\n\n\n","category":"function"},{"location":"user_api/#ThickNumbers.is_strict_supset_tn","page":"User API","title":"ThickNumbers.is_strict_supset_tn","text":"is_strict_supset_tn(a::ThickNumber, b::ThickNumber)\n⪾(a::ThickNumber, b::ThickNumber)\n\nThe converse of is_strict_subset_tn.\n\n\n\n\n\n","category":"function"},{"location":"user_api/","page":"User API","title":"User API","text":"Also supported are Base's:","category":"page"},{"location":"user_api/","page":"User API","title":"User API","text":"isdisjoint\nintersect","category":"page"},{"location":"user_api/#Operations-with-real-numbers","page":"User API","title":"Operations with real numbers","text":"","category":"section"},{"location":"user_api/","page":"User API","title":"User API","text":"clamp(::Real, ::ThickNumber)","category":"page"}]
}
